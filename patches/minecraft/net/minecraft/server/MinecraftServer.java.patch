--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -244,11 +_,30 @@
    private final StructureTemplateManager structureTemplateManager;
    protected final WorldData worldData;
    private volatile boolean isSaving;
+   // CraftBukkit start
+   public WorldLoader.DataLoadContext worldLoader; //Ketting - not final
+   public org.bukkit.craftbukkit.v1_20_R1.CraftServer server;
+   public joptsimple.OptionSet options;
+   public org.bukkit.command.ConsoleCommandSender console;
+   public jline.console.ConsoleReader reader;
+   public static int currentTick = (int) (System.currentTimeMillis() / 50);
+   public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+   public int autosavePeriod;
+   public Commands vanillaCommandDispatcher;
+   private boolean forceTicks;
+   // CraftBukkit end
+   // Spigot start
+   public static final int TPS = 20;
+   public static final int TICK_TIME = 1000000000 / TPS;
+   private static final int SAMPLE_INTERVAL = 100;
+   public final double[] recentTps = new double[ 3 ];
+   // Spigot end
 
    public static <S extends MinecraftServer> S spin(Function<Thread, S> p_129873_) {
       AtomicReference<S> atomicreference = new AtomicReference<>();
-      Thread thread = new Thread(() -> {
+      Thread thread = new Thread(net.minecraftforge.fml.util.thread.SidedThreadGroups.SERVER, () -> {
          atomicreference.get().runServer();
+         Runtime.getRuntime().halt(0); //Ketting - fix server hanging on exit
       }, "Server thread");
       thread.setUncaughtExceptionHandler((p_177909_, p_177910_) -> {
          LOGGER.error("Uncaught exception in server thread", p_177910_);
@@ -267,7 +_,7 @@
       super("Server");
       this.registries = p_236726_.registries();
       this.worldData = p_236726_.worldData();
-      if (!this.registries.compositeAccess().registryOrThrow(Registries.LEVEL_STEM).containsKey(LevelStem.OVERWORLD)) {
+      if (false && !this.registries.compositeAccess().registryOrThrow(Registries.LEVEL_STEM).containsKey(LevelStem.OVERWORLD)) { // CraftBukkit - initialised later
          throw new IllegalStateException("Missing Overworld dimension data");
       } else {
          this.proxy = p_236727_;
@@ -278,7 +_,7 @@
             p_236729_.profileCache().setExecutor(this);
          }
 
-         this.connection = new ServerConnectionListener(this);
+         // this.connection = new ServerConnectionListener(this); // Spigot
          this.progressListenerFactory = p_236730_;
          this.storageSource = p_236724_;
          this.playerDataStorage = p_236724_.createPlayerStorage();
@@ -289,6 +_,31 @@
          this.serverThread = p_236723_;
          this.executor = Util.backgroundExecutor();
       }
+      // CraftBukkit start
+      this.vanillaCommandDispatcher = p_236726_.dataPackResources().commands; // CraftBukkit
+      // Try to see if we're actually running in a terminal, disable jline if not
+      if (System.console() == null && System.getProperty("jline.terminal") == null) {
+         System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+         org.bukkit.craftbukkit.Main.useJline = false;
+      }
+
+      try {
+         reader = new jline.console.ConsoleReader(System.in, System.out);
+         reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+      } catch (Throwable e) {
+         try {
+            // Try again with jline disabled for Windows users without C++ 2008 Redistributable
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            System.setProperty("user.language", "en");
+            org.bukkit.craftbukkit.Main.useJline = false;
+            reader = new jline.console.ConsoleReader(System.in, System.out);
+            reader.setExpandEvents(false);
+         } catch (IOException ex) {
+            LOGGER.warn((String) null, ex);
+         }
+      }
+      Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.v1_20_R1.util.ServerShutdownThread(this));
+      // CraftBukkit end
    }
 
    private void readScoreboard(DimensionDataStorage p_129842_) {
@@ -297,6 +_,18 @@
 
    protected abstract boolean initServer() throws IOException;
 
+   //Ketting start
+   private String loadLevel$worldName;
+   protected void prepareLoadLevel(String worldName) {
+      this.loadLevel$worldName = worldName;
+   }
+
+   public void setBukkitOptions(joptsimple.OptionSet options, WorldLoader.DataLoadContext dataLoadContext) {
+      this.options = options;
+      this.worldLoader = dataLoadContext;
+   }
+   //Ketting end
+
    protected void loadLevel() {
       if (!JvmProfiler.INSTANCE.isRunning()) {
       }
@@ -308,6 +_,13 @@
       this.createLevels(chunkprogresslistener);
       this.forceDifficulty();
       this.prepareLevels(chunkprogresslistener);
+
+      //Ketting start
+      this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
+      this.server.getPluginManager().callEvent(new org.bukkit.event.server.ServerLoadEvent(org.bukkit.event.server.ServerLoadEvent.LoadType.STARTUP));
+      this.connection.acceptConnections();
+      //Ketting end
+
       if (profiledduration != null) {
          profiledduration.finish();
       }
@@ -334,12 +_,21 @@
       long j = BiomeManager.obfuscateSeed(i);
       List<CustomSpawner> list = ImmutableList.of(new PhantomSpawner(), new PatrolSpawner(), new CatSpawner(), new VillageSiege(), new WanderingTraderSpawner(serverleveldata));
       LevelStem levelstem = registry.get(LevelStem.OVERWORLD);
+      //Ketting start - pass bukkit values
+      ServerLevel.init$gen = this.server.getGenerator(loadLevel$worldName);
+      ServerLevel.init$env = org.bukkit.World.Environment.NORMAL;
+      ServerLevel.init$biomeProvider = this.server.getBiomeProvider(loadLevel$worldName);
+      //Ketting end
       ServerLevel serverlevel = new ServerLevel(this, this.executor, this.storageSource, serverleveldata, Level.OVERWORLD, levelstem, p_129816_, flag, j, list, true, (RandomSequences)null);
+      org.kettingpowered.ketting.core.Ketting.getInstance().getDimensionRegistry().get().register(this.registryAccess().registryOrThrow(Registries.LEVEL_STEM)); //Ketting
       this.levels.put(Level.OVERWORLD, serverlevel);
       DimensionDataStorage dimensiondatastorage = serverlevel.getDataStorage();
+      this.server.scoreboardManager = new org.bukkit.craftbukkit.v1_20_R1.scoreboard.CraftScoreboardManager(this, serverlevel.getScoreboard()); // CraftBukkit
       this.readScoreboard(dimensiondatastorage);
       this.commandStorage = new CommandStorage(dimensiondatastorage);
       WorldBorder worldborder = serverlevel.getWorldBorder();
+      net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.level.LevelEvent.Load(levels.get(Level.OVERWORLD)));
+      this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(levels.get(Level.OVERWORLD).getWorld())); // CraftBukkit - SPIGOT-5569: Call WorldInitEvent before any chunks are generated
       if (!serverleveldata.isInitialized()) {
          try {
             setInitialSpawn(serverlevel, serverleveldata, worldoptions.generateBonusChest(), flag);
@@ -373,9 +_,63 @@
          if (resourcekey != LevelStem.OVERWORLD) {
             ResourceKey<Level> resourcekey1 = ResourceKey.create(Registries.DIMENSION, resourcekey.location());
             DerivedLevelData derivedleveldata = new DerivedLevelData(this.worldData, serverleveldata);
-            ServerLevel serverlevel1 = new ServerLevel(this, this.executor, this.storageSource, derivedleveldata, resourcekey1, entry.getValue(), p_129816_, flag, j, ImmutableList.of(), false, randomsequences);
+            derivedleveldata.setTypeKey(resourcekey); //Ketting
+
+            int dimension = 0;
+
+            if (resourcekey == LevelStem.NETHER) {
+               if (isNetherEnabled()) {
+                  dimension = -1;
+               } else {
+                  continue;
+               }
+            } else if (resourcekey == LevelStem.END) {
+               if (server.getAllowEnd()) {
+                  dimension = 1;
+               } else {
+                  continue;
+               }
+            } else {
+               dimension = -999;
+            }
+
+            String worldType = (dimension == -999) ? resourcekey.location().getNamespace() + "_" + resourcekey.location().getPath() : org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase();
+            String name = loadLevel$worldName + "_" + worldType;
+
+            org.bukkit.generator.ChunkGenerator gen = this.server.getGenerator(name);
+            org.bukkit.generator.BiomeProvider biomeProvider = this.server.getBiomeProvider(name);
+
+            LevelStorageSource.LevelStorageAccess source;
+            try {
+               source = LevelStorageSource.createDefault(server.getWorldContainer().toPath()).validateAndCreateAccess(name, resourcekey);
+
+               if (org.kettingpowered.ketting.config.KettingConfig.getInstance().MERGE_WORLD_SYSTEMS.getValue()) {
+                  LevelStorageSource.LevelStorageAccess newSource = this.storageSource.reference.deriveFromSource(this.storageSource, resourcekey);
+
+                  if (org.kettingpowered.ketting.utils.WorldSystemConverter.needsConversion(source, resourcekey1))
+                     org.kettingpowered.ketting.utils.WorldSystemConverter.convert(source, newSource, resourcekey1);
+
+                  source = newSource;
+               }
+            } catch (IOException | net.minecraft.world.level.validation.ContentValidationException e) {
+               throw new RuntimeException(e);
+            }
+
+            //Ketting start - pass bukkit values
+            ServerLevel.init$gen = gen;
+            ServerLevel.init$env = (org.bukkit.World.Environment) org.kettingpowered.ketting.core.Ketting.getInstance().getDimensionRegistry().get().getKey(resourcekey);
+            ServerLevel.init$biomeProvider = biomeProvider;
+            //Ketting end
+            ServerLevel serverlevel1 = new ServerLevel(this, this.executor, source, derivedleveldata, resourcekey1, entry.getValue(), p_129816_, flag, j, ImmutableList.of(), false, randomsequences);
+
+            if (serverlevel1.generator != null) {
+               serverlevel1.getWorld().getPopulators().addAll(serverlevel1.generator.getDefaultPopulators(serverlevel1.getWorld()));
+            }
+
             worldborder.addListener(new BorderChangeListener.DelegateBorderChangeListener(serverlevel1.getWorldBorder()));
             this.levels.put(resourcekey1, serverlevel1);
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.level.LevelEvent.Load(levels.get(resourcekey)));
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(serverlevel1.getWorld())); // CraftBukkit - SPIGOT-5569: Call WorldInitEvent before any chunks are generated
          }
       }
 
@@ -387,7 +_,23 @@
          p_177898_.setSpawn(BlockPos.ZERO.above(80), 0.0F);
       } else {
          ServerChunkCache serverchunkcache = p_177897_.getChunkSource();
+         if (net.minecraftforge.event.ForgeEventFactory.onCreateWorldSpawn(p_177897_, p_177898_)) return;
          ChunkPos chunkpos = new ChunkPos(serverchunkcache.randomState().sampler().findSpawnPosition());
+         // CraftBukkit start
+         if (p_177897_.generator != null) {
+            java.util.Random rand = new java.util.Random(p_177897_.getSeed());
+            org.bukkit.Location spawn = p_177897_.generator.getFixedSpawnLocation(p_177897_.getWorld(), rand);
+
+            if (spawn != null) {
+               if (spawn.getWorld() != p_177897_.getWorld()) {
+                  throw new IllegalStateException("Cannot set spawn point for " + p_177898_.getLevelName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+               } else {
+                  p_177898_.setSpawn(new BlockPos(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()), spawn.getYaw());
+                  return;
+               }
+            }
+         }
+         // CraftBukkit end
          int i = serverchunkcache.getGenerator().getSpawnHeight(p_177897_);
          if (i < p_177897_.getMinBuildHeight()) {
             BlockPos blockpos = chunkpos.getWorldPosition();
@@ -442,8 +_,23 @@
       serverleveldata.setGameType(GameType.SPECTATOR);
    }
 
+   //Ketting Start
+   private @Nullable ServerLevel worldserver = null;
+   public void prepareLevels(ChunkProgressListener p_129941_, ServerLevel worldserver){
+      this.worldserver = worldserver;
+      prepareLevels(p_129941_);
+   }
+   //Ketting End
+
    private void prepareLevels(ChunkProgressListener p_129941_) {
+      this.forceTicks = true; // CraftBukkit
       ServerLevel serverlevel = this.overworld();
+      //Ketting Start
+      if (worldserver != null) {
+         serverlevel = worldserver;
+         worldserver = null;
+      }
+      //Ketting End
       LOGGER.info("Preparing start region for dimension {}", (Object)serverlevel.dimension().location());
       BlockPos blockpos = serverlevel.getSharedSpawnPos();
       p_129941_.updateSpawnPos(new ChunkPos(blockpos));
@@ -451,13 +_,11 @@
       this.nextTickTime = Util.getMillis();
       serverchunkcache.addRegionTicket(TicketType.START, new ChunkPos(blockpos), 11, Unit.INSTANCE);
 
-      while(serverchunkcache.getTickingGenerated() != 441) {
-         this.nextTickTime = Util.getMillis() + 10L;
-         this.waitUntilNextTick();
+      while (serverchunkcache.getTickingGenerated() < 441) {
+         this.executeModerately();
       }
 
-      this.nextTickTime = Util.getMillis() + 10L;
-      this.waitUntilNextTick();
+      this.executeModerately();
 
       for(ServerLevel serverlevel1 : this.levels.values()) {
          ForcedChunksSavedData forcedchunkssaveddata = serverlevel1.getDataStorage().get(ForcedChunksSavedData::load, "chunks");
@@ -469,13 +_,19 @@
                ChunkPos chunkpos = new ChunkPos(i);
                serverlevel1.getChunkSource().updateChunkForced(chunkpos, true);
             }
+            net.minecraftforge.common.world.ForgeChunkManager.reinstatePersistentChunks(serverlevel1, forcedchunkssaveddata);
          }
+
+         // CraftBukkit start
+         serverlevel1.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API
+         this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(serverlevel1.getWorld()));
+         // CraftBukkit end
       }
 
-      this.nextTickTime = Util.getMillis() + 10L;
-      this.waitUntilNextTick();
+      this.executeModerately();
       p_129941_.stop();
       this.updateMobSpawningFlags();
+      this.forceTicks = false; // CraftBukkit
    }
 
    public GameType getDefaultGameType() {
@@ -504,11 +_,13 @@
          flag = true;
       }
 
+      // Ketting start - stay here
       ServerLevel serverlevel2 = this.overworld();
       ServerLevelData serverleveldata = this.worldData.overworldData();
       serverleveldata.setWorldBorder(serverlevel2.getWorldBorder().createSettings());
-      this.worldData.setCustomBossEvents(this.getCustomBossEvents().save());
-      this.storageSource.saveDataTag(this.registryAccess(), this.worldData, this.getPlayerList().getSingleplayerData());
+      ((net.minecraft.world.level.storage.PrimaryLevelData) serverleveldata).setCustomBossEvents(this.getCustomBossEvents().save());
+      serverlevel2.convertable.saveDataTag(this.registryAccess(), (net.minecraft.world.level.storage.PrimaryLevelData) serverleveldata, this.getPlayerList().getSingleplayerData());
+      // Ketting end
       if (p_129887_) {
          for(ServerLevel serverlevel1 : this.getAllLevels()) {
             LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)serverlevel1.getChunkSource().chunkMap.getStorageName());
@@ -537,12 +_,33 @@
       this.stopServer();
    }
 
+   // CraftBukkit start
+   private boolean hasStopped = false;
+   private final Object stopLock = new Object();
+   public final boolean hasStopped() {
+      synchronized (stopLock) {
+         return hasStopped;
+      }
+   }
+   // CraftBukkit end
+
    public void stopServer() {
+      // CraftBukkit start - prevent double stopping on multiple threads
+      synchronized(stopLock) {
+         if (hasStopped) return;
+         hasStopped = true;
+      }
+      // CraftBukkit end
       if (this.metricsRecorder.isRecording()) {
          this.cancelRecordingMetrics();
       }
 
       LOGGER.info("Stopping server");
+      // CraftBukkit start
+      if (this.server != null) {
+         this.server.disablePlugins();
+      }
+      // CraftBukkit end
       if (this.getConnection() != null) {
          this.getConnection().stop();
       }
@@ -552,6 +_,7 @@
          LOGGER.info("Saving players");
          this.playerList.saveAll();
          this.playerList.removeAll();
+         try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
       }
 
       LOGGER.info("Saving worlds");
@@ -582,6 +_,7 @@
       for(ServerLevel serverlevel2 : this.getAllLevels()) {
          if (serverlevel2 != null) {
             try {
+               net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.level.LevelEvent.Unload(serverlevel2));
                serverlevel2.close();
             } catch (IOException ioexception1) {
                LOGGER.error("Exception closing the level", (Throwable)ioexception1);
@@ -598,6 +_,12 @@
          LOGGER.error("Failed to unlock level {}", this.storageSource.getLevelId(), ioexception);
       }
 
+      // Spigot start
+      if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
+         LOGGER.info("Saving usercache.json");
+         this.getProfileCache().save();
+      }
+      // Spigot end
    }
 
    public String getLocalIp() {
@@ -624,30 +_,56 @@
 
    }
 
+   // Spigot Start
+   private static double calcTps(double avg, double exp, double tps)
+   {
+      return ( avg * exp ) + ( tps * ( 1 - exp ) );
+   }
+   // Spigot End
+
    protected void runServer() {
       try {
          if (!this.initServer()) {
             throw new IllegalStateException("Failed to initialize server");
          }
 
+         net.minecraftforge.server.ServerLifecycleHooks.handleServerStarted(this);
          this.nextTickTime = Util.getMillis();
-         this.statusIcon = this.loadStatusIcon().orElse((ServerStatus.Favicon)null);
+         this.statusIcon = this.loadStatusIcon().orElse((ServerStatus.Favicon) null);
          this.status = this.buildServerStatus();
-
-         while(this.running) {
-            long i = Util.getMillis() - this.nextTickTime;
-            if (i > 2000L && this.nextTickTime - this.lastOverloadWarning >= 15000L) {
+         resetStatusCache(status);
+
+         // Spigot start
+         Arrays.fill( recentTps, 20 );
+         long curTime, tickSection = Util.getMillis(), tickCount = 1;
+         while (this.running) {
+            long i = (curTime = Util.getMillis()) - this.nextTickTime;
+
+            if (i > 5000L && this.nextTickTime - this.lastOverloadWarning >= 30000L) { // CraftBukkit
                long j = i / 50L;
-               LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
+
+               if (server.getWarnOnOverload())
+                  LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
                this.nextTickTime += j * 50L;
                this.lastOverloadWarning = this.nextTickTime;
             }
 
+            if ( tickCount++ % SAMPLE_INTERVAL == 0 )
+            {
+               double currentTps = 1E3 / ( curTime - tickSection ) * SAMPLE_INTERVAL;
+               recentTps[0] = calcTps( recentTps[0], 0.92, currentTps ); // 1/exp(5sec/1min)
+               recentTps[1] = calcTps( recentTps[1], 0.9835, currentTps ); // 1/exp(5sec/5min)
+               recentTps[2] = calcTps( recentTps[2], 0.9945, currentTps ); // 1/exp(5sec/15min)
+               tickSection = curTime;
+            }
+            // Spigot end
+
             if (this.debugCommandProfilerDelayStart) {
                this.debugCommandProfilerDelayStart = false;
                this.debugCommandProfiler = new MinecraftServer.TimeProfiler(Util.getNanos(), this.tickCount);
             }
 
+            MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit
             this.nextTickTime += 50L;
             this.startMetricsRecordingTick();
             this.profiler.push("tick");
@@ -661,8 +_,18 @@
             this.isReady = true;
             JvmProfiler.INSTANCE.onServerTick(this.averageTickTime);
          }
+         net.minecraftforge.server.ServerLifecycleHooks.handleServerStopping(this);
+         net.minecraftforge.server.ServerLifecycleHooks.expectServerStopped(); // Forge: Has to come before MinecraftServer#onServerCrash to avoid race conditions
+      } catch (org.spongepowered.asm.mixin.throwables.MixinError mixin) {
+         org.kettingpowered.ketting.core.injectprotect.InjectProtect.mixinInjectCaught(null, mixin);
       } catch (Throwable throwable1) {
          LOGGER.error("Encountered an unexpected exception", throwable1);
+         // Spigot Start
+         if ( throwable1.getCause() != null )
+         {
+            MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable1.getCause() );
+         }
+         // Spigot End
          CrashReport crashreport = constructOrExtractCrashReport(throwable1);
          this.fillSystemReport(crashreport.getSystemReport());
          File file1 = new File(new File(this.getServerDirectory(), "crash-reports"), "crash-" + Util.getFilenameFormattedDateTime() + "-server.txt");
@@ -672,6 +_,7 @@
             LOGGER.error("We were unable to save this crash report to disk.");
          }
 
+         net.minecraftforge.server.ServerLifecycleHooks.expectServerStopped(); // Forge: Has to come before MinecraftServer#onServerCrash to avoid race conditions
          this.onServerCrash(crashreport);
       } finally {
          try {
@@ -684,6 +_,15 @@
                this.services.profileCache().clearExecutor();
             }
 
+            net.minecraftforge.server.ServerLifecycleHooks.handleServerStopped(this);
+
+            org.spigotmc.WatchdogThread.doStop(); // Spigot
+            // CraftBukkit start - Restore terminal to original settings
+            try {
+               reader.getTerminal().restore();
+            } catch (Exception ignored) {
+            }
+            // CraftBukkit end
             this.onServerExit();
          }
 
@@ -714,7 +_,7 @@
    }
 
    private boolean haveTime() {
-      return this.runningTask() || Util.getMillis() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTime : this.nextTickTime);
+      return this.forceTicks || this.runningTask() || Util.getMillis() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTime : this.nextTickTime); // CraftBukkit
    }
 
    protected void waitUntilNextTick() {
@@ -724,6 +_,18 @@
       });
    }
 
+   private void executeModerately() {
+      this.runAllTasks();
+      this.drainQueuedTasks();
+      java.util.concurrent.locks.LockSupport.parkNanos("executing tasks", 1000L);
+   }
+
+   public void drainQueuedTasks() {
+      while (!processQueue.isEmpty()) {
+         processQueue.remove().run();
+      }
+   }
+
    public TickTask wrapRunnable(Runnable p_129852_) {
       return new TickTask(this.tickCount, p_129852_);
    }
@@ -797,20 +_,26 @@
    }
 
    public void tickServer(BooleanSupplier p_129871_) {
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.serverTickTimer.startTiming(); // Spigot
       long i = Util.getNanos();
+
+      net.minecraftforge.event.ForgeEventFactory.onPreServerTick(p_129871_, this);
       ++this.tickCount;
       this.tickChildren(p_129871_);
-      if (i - this.lastServerStatus >= 5000000000L) {
+      if (!cacheDisabled && i - this.lastServerStatus >= 5000000000L) { //Ketting - cacheDisabled
          this.lastServerStatus = i;
          this.status = this.buildServerStatus();
+         resetStatusCache(status);
       }
 
-      if (this.tickCount % 6000 == 0) {
+      if (autosavePeriod > 0 && this.tickCount % autosavePeriod == 0) { // CraftBukkit
+         org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.worldSaveTimer.startTiming(); // Spigot
          LOGGER.debug("Autosave started");
          this.profiler.push("save");
          this.saveEverything(true, false, false);
          this.profiler.pop();
          LOGGER.debug("Autosave finished");
+         org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
       }
 
       this.profiler.push("tallying");
@@ -819,13 +_,37 @@
       long k = Util.getNanos();
       this.frameTimer.logFrameDuration(k - i);
       this.profiler.pop();
+      net.minecraftforge.event.ForgeEventFactory.onPostServerTick(p_129871_, this);
+      org.spigotmc.WatchdogThread.tick(); // Spigot
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.serverTickTimer.stopTiming(); // Spigot
+      org.spigotmc.CustomTimingsHandler.tick(); // Spigot
+   }
+
+   private static final com.google.gson.Gson GSON = new com.google.gson.Gson();
+   public String cachedServerStatus; // FORGE: cache the server status json in case a client spams requests //Ketting - private -> public
+   private void resetStatusCache(ServerStatus status) {
+      this.cachedServerStatus = GSON.toJson(ServerStatus.CODEC.encodeStart(com.mojang.serialization.JsonOps.INSTANCE, status)
+              .result().orElseThrow());
+   }
+   public String getStatusJson() {
+      return cachedServerStatus;
    }
 
    private ServerStatus buildServerStatus() {
       ServerStatus.Players serverstatus$players = this.buildPlayerStatus();
-      return new ServerStatus(Component.nullToEmpty(this.motd), Optional.of(serverstatus$players), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile());
+      return new ServerStatus(Component.nullToEmpty(this.motd), Optional.of(serverstatus$players), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile(), Optional.of(new net.minecraftforge.network.ServerStatusPing()));
+   }
+   //Ketting start
+   private boolean cacheDisabled;
+   public void disableStatusCache() {
+      this.cacheDisabled = true;
    }
 
+   public String statusToJson(ServerStatus status) {
+      return GSON.toJson(ServerStatus.CODEC.encodeStart(com.mojang.serialization.JsonOps.INSTANCE, status)
+              .result().orElseThrow());
+   }
+   //Ketting end
    private ServerStatus.Players buildPlayerStatus() {
       List<ServerPlayer> list = this.playerList.getPlayers();
       int i = this.getMaxPlayers();
@@ -847,47 +_,92 @@
    }
 
    public void tickChildren(BooleanSupplier p_129954_) {
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.schedulerTimer.startTiming(); // Spigot
+      this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.schedulerTimer.stopTiming(); // Spigot
       this.profiler.push("commandFunctions");
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.commandFunctionsTimer.startTiming(); // Spigot
       this.getFunctions().tick();
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.commandFunctionsTimer.stopTiming(); // Spigot
       this.profiler.popPush("levels");
 
-      for(ServerLevel serverlevel : this.getAllLevels()) {
+      // CraftBukkit start
+      // Run tasks that are waiting on processing
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.processQueueTimer.startTiming(); // Spigot
+      while (!processQueue.isEmpty()) {
+         processQueue.remove().run();
+      }
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.processQueueTimer.stopTiming(); // Spigot
+
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
+      // Send time updates to everyone, it will get the right time from the world the player is in.
+      if (this.tickCount % 20 == 0) {
+         for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
+            ServerPlayer serverplayer = (ServerPlayer) this.getPlayerList().players.get(i);
+            serverplayer.connection.send(new ClientboundSetTimePacket(serverplayer.level().getGameTime(), serverplayer.getPlayerTime(), serverplayer.level().getGameRules().getBoolean(GameRules.RULE_DAYLIGHT))); // Add support for per player time
+         }
+      }
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
+
+      for(ServerLevel serverlevel : this.getWorldArray()) {
+         long tickStart = Util.getNanos();
          this.profiler.push(() -> {
             return serverlevel + " " + serverlevel.dimension().location();
          });
+         /* Drop global time updates
          if (this.tickCount % 20 == 0) {
             this.profiler.push("timeSync");
             this.synchronizeTime(serverlevel);
             this.profiler.pop();
          }
+         // CraftBukkit end */
 
          this.profiler.push("tick");
+         net.minecraftforge.event.ForgeEventFactory.onPreLevelTick(serverlevel, p_129954_);
 
          try {
+            serverlevel.timings.doTick.startTiming(); // Spigot
             serverlevel.tick(p_129954_);
+            serverlevel.timings.doTick.stopTiming(); // Spigot
          } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+            // Spigot Start
+            CrashReport crashreport;
+            try {
+               crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+            } catch (Throwable t) {
+               throw new RuntimeException("Error generating crash report", t);
+            }
+            // Spigot End
+
             serverlevel.fillReportDetails(crashreport);
             throw new ReportedException(crashreport);
          }
+         net.minecraftforge.event.ForgeEventFactory.onPostLevelTick(serverlevel, p_129954_);
 
          this.profiler.pop();
          this.profiler.pop();
+         perWorldTickTimes.computeIfAbsent(serverlevel.dimension(), k -> new long[100])[this.tickCount % 100] = Util.getNanos() - tickStart;
       }
 
       this.profiler.popPush("connection");
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.connectionTimer.startTiming(); // Spigot
       this.getConnection().tick();
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.connectionTimer.stopTiming(); // Spigot
       this.profiler.popPush("players");
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.playerListTimer.startTiming(); // Spigot
       this.playerList.tick();
-      if (SharedConstants.IS_RUNNING_IN_IDE) {
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.playerListTimer.stopTiming(); // Spigot
+      if (net.minecraftforge.gametest.ForgeGameTestHooks.isGametestEnabled()) {
          GameTestTicker.SINGLETON.tick();
       }
 
       this.profiler.popPush("server gui refresh");
 
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.tickablesTimer.startTiming(); // Spigot
       for(int i = 0; i < this.tickables.size(); ++i) {
          this.tickables.get(i).run();
       }
+      org.bukkit.craftbukkit.v1_20_R1.SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
       this.profiler.pop();
    }
@@ -935,6 +_,22 @@
       return this.levels.get(p_129881_);
    }
 
+   // CraftBukkit start
+   public void addLevel(ServerLevel level) {
+      Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
+      Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
+      newLevels.put(level.dimension(), level);
+      this.levels = Collections.unmodifiableMap(newLevels);
+   }
+
+   public void removeLevel(ServerLevel level) {
+      Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
+      Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
+      newLevels.remove(level.dimension());
+      this.levels = Collections.unmodifiableMap(newLevels);
+   }
+   // CraftBukkit end
+
    public Set<ResourceKey<Level>> levelKeys() {
       return this.levels.keySet();
    }
@@ -961,7 +_,7 @@
 
    @DontObfuscate
    public String getServerModName() {
-      return "vanilla";
+      return org.kettingpowered.ketting.internal.KettingConstants.NAME; //net.minecraftforge.internal.BrandingControl.getServerBranding(); //Ketting
    }
 
    public SystemReport fillSystemReport(SystemReport p_177936_) {
@@ -1164,7 +_,7 @@
 
    @Nullable
    public ServerConnectionListener getConnection() {
-      return this.connection;
+      return this.connection == null ? this.connection = new ServerConnectionListener(this) : this.connection; // Spigot
    }
 
    public boolean isReady() {
@@ -1303,6 +_,13 @@
       }).thenAcceptAsync((p_248090_) -> {
          this.resources.close();
          this.resources = p_248090_;
+         //Ketting start
+         this.server.doSync(p_248090_.managers().commands);
+         if (this instanceof net.minecraft.server.dedicated.DedicatedServer ded && ded.betterGui != null)
+            ded.betterGui.reload();
+         org.kettingpowered.ketting.core.Ketting.getInstance().reload();
+         org.kettingpowered.ketting.metrics.MetricManager.reload();
+         //Ketting end
          this.packRepository.setSelected(p_129862_);
          WorldDataConfiguration worlddataconfiguration = new WorldDataConfiguration(getSelectedPacks(this.packRepository), this.worldData.enabledFeatures());
          this.worldData.setDataConfiguration(worlddataconfiguration);
@@ -1311,6 +_,7 @@
          this.getPlayerList().reloadResources();
          this.functionManager.replaceLibrary(this.resources.managers.getFunctionLibrary());
          this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
+         this.getPlayerList().getPlayers().forEach(this.getPlayerList()::sendPlayerPermissionLevel); //Forge: Fix newly added/modified commands not being sent to the client when commands reload.
       }, this);
       if (this.isSameThread()) {
          this.managedBlock(completablefuture::isDone);
@@ -1320,10 +_,13 @@
    }
 
    public static WorldDataConfiguration configurePackRepository(PackRepository p_248681_, DataPackConfig p_248920_, boolean p_249869_, FeatureFlagSet p_251243_) {
+      net.minecraftforge.resource.ResourcePackLoader.loadResourcePacks(p_248681_, net.minecraftforge.server.ServerLifecycleHooks::buildPackFinder);
       p_248681_.reload();
+      DataPackConfig.DEFAULT.addModPacks(net.minecraftforge.common.ForgeHooks.getModPacks());
+      p_248920_.addModPacks(net.minecraftforge.common.ForgeHooks.getModPacks());
       if (p_249869_) {
-         p_248681_.setSelected(Collections.singleton("vanilla"));
-         return WorldDataConfiguration.DEFAULT;
+         p_248681_.setSelected(net.minecraftforge.common.ForgeHooks.getModPacksWithVanilla());
+         return new WorldDataConfiguration(new DataPackConfig(net.minecraftforge.common.ForgeHooks.getModPacksWithVanilla(), ImmutableList.of()), FeatureFlags.DEFAULT_FLAGS);
       } else {
          Set<String> set = Sets.newLinkedHashSet();
 
@@ -1481,6 +_,31 @@
 
    public abstract boolean isSingleplayerOwner(GameProfile p_129840_);
 
+   private Map<ResourceKey<Level>, long[]> perWorldTickTimes = Maps.newIdentityHashMap();
+   @Nullable
+   public long[] getTickTime(ResourceKey<Level> dim) {
+      return perWorldTickTimes.get(dim);
+   }
+
+   @Deprecated //Forge Internal use Only, You can screw up a lot of things if you mess with this map.
+   public synchronized Map<ResourceKey<Level>, ServerLevel> forgeGetWorldMap() {
+      return this.levels;
+   }
+   private int worldArrayMarker = 0;
+   private int worldArrayLast = -1;
+   private ServerLevel[] worldArray;
+   @Deprecated //Forge Internal use Only, use to protect against concurrent modifications in the world tick loop.
+   public synchronized void markWorldsDirty() {
+      worldArrayMarker++;
+   }
+   private ServerLevel[] getWorldArray() {
+      if (worldArrayMarker == worldArrayLast && worldArray != null)
+         return worldArray;
+      worldArray = this.levels.values().stream().toArray(x -> new ServerLevel[x]);
+      worldArrayLast = worldArrayMarker;
+      return worldArray;
+   }
+
    public void dumpServerProperties(Path p_177911_) throws IOException {
    }
 
@@ -1583,6 +_,22 @@
       }
    }
 
+   // CraftBukkit start
+   @Override
+   public boolean isSameThread() {
+      return super.isSameThread() || this.isStopped(); // CraftBukkit - MC-142590
+   }
+
+   public boolean isDebugging() {
+      return false;
+   }
+
+   @Deprecated
+   public static MinecraftServer getServer() {
+      return (org.bukkit.Bukkit.getServer() instanceof org.bukkit.craftbukkit.v1_20_R1.CraftServer) ? ((org.bukkit.craftbukkit.v1_20_R1.CraftServer) org.bukkit.Bukkit.getServer()).getServer() : null;
+   }
+   // CraftBukkit end
+
    private void startMetricsRecordingTick() {
       if (this.willStartRecordingMetrics) {
          this.metricsRecorder = ActiveMetricsRecorder.createStarted(new ServerMetricsSamplersProvider(Util.timeSource, this.isDedicatedServer()), Util.timeSource, Util.ioPool(), new MetricsPersister("server"), this.onMetricsRecordingStopped, (p_212927_) -> {
@@ -1646,6 +_,10 @@
       return this.worldData;
    }
 
+   public MinecraftServer.ReloadableResources getServerResources() {
+       return resources;
+   }
+
    public RegistryAccess.Frozen registryAccess() {
       return this.registries.compositeAccess();
    }
@@ -1706,6 +_,11 @@
       }
 
    }
+
+   // CraftBukkit start
+   public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
+           new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").build());
+   // CraftBukkit end
 
    public ChatDecorator getChatDecorator() {
       return ChatDecorator.PLAIN;
